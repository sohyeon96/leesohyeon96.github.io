---
layout: page
title: About me
subtitle: 개발자를 하기 위해 포항에서 올라온 성실한 예비 개발자
---

- 관심있는 기술 : java, 최근에는 ajax, 게임 만들기 위한 C언어, jpa(외국에서 많이 사용한다고 하며 mybatis보다 코드가 간단해진다는 장점)

- 사용한 기술 : java(가장 보편화 되있으며.. 작성예정 ), jdbc, oracle, jquery, javascript, tomcat 등..

- 어떤 개발자가 되고 싶은가 ? 자기계발을 열심히 하며 맡은 일에 최선을 다해 같이 일하고 싶은 개발자

  -> 이를 위해 한 노력 ? 1) 비전공자로 왔기 때문에 부끄러움 없이 모르는 부분은 질문하고 혼자 구글링 등을 하여 (노션에 정리한 거 단편적인 부분 보여주고) 기본 개념 등을 숙지하려 노력하였습니다. 또한 배운 개념을 활용하여 개인 미니 프로젝트를 만들기도 하였습니다. (scanner를 이용한 고양이 키우기 게임(코드 조금 보여주기)) 또한 dailylog라는 매일 쓰는 개발일기를 하루도 빠짐없이 작성하여 본인의 위치를 파악하고 돌아보며 반성할 수 있도록 하였습니다.

  -> 2) 또한 첫 미니 프로젝트때 한 활동과 본인 코드 , 적극적인 모습(프로토타이핑, 코드 친 부분, wbs관리 등)

  -> 3) 세미 프로젝트 때 PM을 맡아 회의록, 개발진행사항, 개발업무일지 등 성실하게 작성 + 팀원 한마디(남들이 보는 나는 이런 사람이다. 라는 걸 어필) + 코드 보여주며(제일 잘한 부분) 어떤 생각으로 이렇게 작성했는 지 간결하면서도 구체적으로 (기능 1~2개를 crud로 분석해서 + 그림그린거까지해서 올리면 좋을 듯, 나머지 코드는 찍어서 올리고(잘한부분만)) + 객체지향의 5대 특징 중 하나인 '코드 의존성?이 높으면 안되는거' 를 지키기 위해서 하나의 controller에는 하나의 service만 부르도록 했다(코드 사진 보여주면서 ㅇㅇ) + (etc)

  (3 -> 세미프로젝트 작성!!)

  - 자바11사용한 이유 : LTS라서(만들어 놓고 지원안하면 거시기하니까 + 유지보수용?) -> 강사님은 우리 수업용이라서 한거 (11버전부터 한거 TOOL때문에)

  - 역할 : PM (일정관리, 이슈트레킹, 개발업무일지 정리 등)

  - 팀원 한마디  ![image-20220314170202086](C:\Users\vkfks\AppData\Roaming\Typora\typora-user-images\image-20220314170202086.png)

    -> 요약 : 의사소통이 활발하며 적극적인 팀원 

  - 코드 리뷰 

    1) 비밀번호 찾기 - 이메일 인증번호 발송
    2) 캘린더 API 사용 (/list or /regist 부분 보여주기)
    3) 멤버 계정 관리 (/list or /regist 부분 보여주기)

    [요구사항명세서 - 유스케이스 다이어그램 - DB설계 테이블 - 프로그램 목록 및 상세(유스케이스다이어그램 등 보여주기)]






  -> 4) 파이널 관련 내용

  -> 5) 또한 spring framework에 이르러 이해가 안되는 부분은 따로 구글링, 책, 주변 사람들의 조언 등으로 혼자 정리하고 있다. (밑에 적은 거 보여주면 될듯?)

  5-1) 내가 잘 모르는 개념, 알고 싶은 개념 -> spring framwork 3대 특징(ioc, aop, psa?) / tcp 프로토콜 이런거 / webServelet 등 이런거?

  5-2) 알아야 하는 개념 -> framework의 개념 / 기초적인 it개념 및 it용어 /

상식으로 알아둘것  -> 자바8이 2030년까지 지원하는 이유 ? 자바의 전성기였을때였기 때문에 이걸 없애버리면 자바 유저들이 떠나갈까봐 + 회사들에서 기본적으로 많이 쓰고 있기 때문에! 

  5-3) 중요한 개념 -> spring framework의 개념! / reflect / rest api 등등

- 오늘 해야할 투두리스트

```java
public void test() {
    System.out.print("hello world"); 
}
```

![img](file://C:%5CUsers%5Cvkfks%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2022-02-14-16-14-57-image.png)

-> 사이사이 그림 채우기 이해하고! (그림 그려보기)

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

[밑에부터는 내가 모르는 개념, 알아야하는 개념, 중요한 개념]

# 프레임 워크란?

:

# Spring 의 3대 특징

- IOC(DI) / PAS(서비스 추상화) / AOS(관점 지향 프로그램)

# 컨테이너란?

: 내가 작성한 코드의 '**처리과정을 위임받은 독립적인 존재**'

: 보통 '**인스턴스의 생명주기를 관리**' 하며 , 그 생성된 인스턴스들에게 추가적인 기능을  제공하도록 하는 것!

# 레가시 :

- 디스페치서블릿 = 컨트롤러 인데 , 디스패치서블릿을 우리맘대로 바꿔줄 수 없스니까 그때 사용하는 것이 핸들러매핑임
- 핸들러 = 조작하기 위함 (우리가 작성한 코드가 작성하게 하기 위해)
- 그리고 우리가 작성한 코드를 작성하는 메소드 = 핸들러 메소드

# 디스페처 서블릿

: dispatch(보내다) - 중간 관리자 역할을 한다(방향을 저장하고 지정해서 요청해주는)

: 즉, 가장 앞단에서 HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 '위임' 해주는 '프론트 컨트롤러(Front Controller -> 약간 '우리 컨트롤러들 찾아갈꺼면 내 통해서 가라! 이런느낌? ')' 라고 정의할 수 있다.

: [구체적인 예시] 클라이언트로 어떠한 요청이 오면 톰캣(Tomat)과 같은 서블릿 컨테이너가 요청을 받음 > 이 모든 요청을 먼저 프론트 컨트롤러인 '디스패처 서블릿'이 받게 됨 > 디스패처 서블릿이 공통적인 작업(ex. 예외가 발생하였을 때 일관된 방식으로 처리하는 것도 프론트 컨트롤러인 디스패처 서블릿이 담당)을 먼저 처리한 후 해당 요청을 처리하는 세부 컨트롤러를 getBean()으로 가져오고, (아마 각 컨트롤러?)컨트롤러에게 작업을 위임함 >

- 프론트 컨트롤러 : 주로 서블릿 컨테이너의 제일 앞에서

  서버로 들어오는 클라이언트의 모든 

  요청을 받아서 처리해주는 컨트롤러

  (MVC 구조에서 함께 사용되는 디자인 패턴)

: <디스패처 서블릿이 하는 역할에 대한 !! 강사님 설명> ioc컨테이너가 실행을 하면 '핸들러매핑'이라는 객체가 map방식으로 key에 (url(url+get/post방식인지), registMenu()(ㄹㅇ 그 길었던 거 메소드자체))를 보관(Handler Mapping이 그 매핑정보를 저장하는 레지스트리임)을 함  /menu/reigst라는 요청주소가 들어오면 위에있는 메핑주소에서 해당 url에 대한 매핑값을 꺼내가지고옴 -> 그럼 registMenu()메소드가 호출됨!  어떤 상황에서 위에서 만들어준 /menu/modify 등... 이런거를 호출할 지 사전에 정의를 해놈(각기 다른 핸들러 메소드들이 동작을 한다!) 반환받은 문자열을 getDRequsetDispatcher를 통해 prefix, suffix붙여서 포워드를 해줌

그래서 registory등록을 하기위해서 RequestMapping을 이용을 한것!

<약간 심화?>

웹컨테이너, 서블릿컨테이너(웹이니까) == 톰캣 스프링 컨테이너 == 빈팩토리

입니다

:사실상 디스패처 서블릿(스프링전용)은 서블릿이 아니고 코드를 열어보면 FrameworkServlet임 그리고 HttpServeltBean(빈으로 사용하기 위한 용도의 서블릿이고 HttpServlet을 상속받음)이라는 걸 상속받았음 그래서  -> 그 서블릿 빈이 빈이기도 하면서 , 서블릿이기도 함 (요약: 스프링 전용 서블릿- bean으로 사용하기 위해서 만들어둔 용도의 클래스)

![img](file://C:%5CUsers%5Cvkfks%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2022-02-10-17-51-09-image.png)

< / 에 대한 질문 >

[김진호] [오후 4:32] 흠.. 매핑 설정을 안했다고 보는게 맞을거같아요 [김진호] [오후 4:32] 서블릿 컨테이너 켤 때 인스턴스 만들면서 [김진호] [오후 4:32] ioc 컨테이너를 만들구요 [김진호] [오후 4:33] 모든 요청에 대해 단일 요청으로 항상 dispatcherservlet을 요청하게 둔거에요 [김진호] [오후 4:33] 즉 /*의 의미인거에요

```
    <servlet>
        <servlet-name>appServlet</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/spring/appServlet/servlet-context.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>

    <!-- 모든 요청에 대해 단일요청으로 항상 디스패처서블릿을 요청하게 둔것! -->
    <servlet-mapping>
        <servlet-name>appServlet</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>

</web-app>
```

-> 원래 url에서 '/' 라는 게 붙음 , artifactId(쳐야지 드갈 수 있는거)만 쳐도 자동으로 붙음 근데 클라이언트가 요청을 할 때 무조건 dispatcherServlet을 거처 갈 수 있도록(프론트 컨트롤러이기 때문에) url-pattern을 '/'로 해준 것

## @Controller

@Controller //얘는 결국 dispatcherservlet이고 ,, 핸들러 메소드가 메핑 레지스토리에 저장해한다 ,, invoke는 핸들러 메소드 호출한 것 ,,

## annotaion-driven

강사님 저번에 annotation-driven 이 @Controller 하위에 있는 Handler 메소드들 Mapping 하기 위한 어노테이션을 활성화 시키는 거라고 하셨는데 그러면 @ResultMapping의 어노테이션들(오늘배운 @Post,Get, 이런거 포함해서)을 활성화시키는 걸 도와주는 태그라고 이해하면 될까요? 네 맞습니다!

# TCP, 연결 지향 프로토콜

-> TCP (Transmission Control Protocol) : 전송조종규약 , 핵심 프로토콜 중 하나

TCP/IP(Internet Protocol)라는 명칭으로도 널리 불림

-> 컴퓨터가 서로 통신하는 경우, 특정 규칙이나 프로토콜을 사용하여 **순서대로 데이터를 전송 및 수신**할 수 있음

###### 정보를 연결하고 교환하는 많은 유형의 네트워크 기술을 허용하며, 네트워크 하드웨어의 세부사항들을 숨길 수 있습니다.

[강사님 설명]

면접에 자주 나옴

http는 tcp라는 프로토콜 위에 있음

웹소켓이라는 것도 tcp라는 프로토콜 위에 있는데

**차이점 : 무연결(http), 지속 연결(웹소켓) -> 요청과 수락**

## session(서버가 관리)이 뭔가? 사용하는 이유?

-> 사용자가 웹 브라우저를 통해 웹서버에 접속한 시점부터 웹 브라우저를 종료하여 연결 끝내는 시점까지, 같은 사용자로부터 오는 일련의 요청을 하나의 상태로 보고, 그 상태를 일정하게 유지하는 기술!

###### 즉, 방문자가 웹 서버에 접속해있는 상태를 하나의 단위로 보고 그것을 '세션'이라고 함

###### 특징

웹서버에 웹 컨테이너 상태를 유지하기 위한 정보 저장

'세션ID'로 클라이언트를 구분하여 각 클라이언트 요구에 맞는 서비스를 제공함

[강사님 설명]

페이지를 전환하는 방식 forward에서만 request로 하고 redirect는 새롭게 전달하는 거라 request공유 못함 그래서 reuqest보다 더 넓은 범위에 session에 넣어놓으면 redirect로도 세션이용할 수 있음 (무상태 무연결(ConnectLess Stateless))

## 쿠키란?

-> 클라이언트가 관리하는 세션 느낌?

http 의 일종으로 웹사이트 방문 시 , 그 사이트가 사용하고 있는 서버에서 사용자의 클라이언트에 저장하는 기록데이터 파일

http에서 클라이언트의 상태정보를 클라이언트에 저장해두었다가 필요시 정보를 참고, 재사용 한다.

###### 특징

이름, 값, 만료일, 경로정보로 구성됨

## 그럼 쿠키와 세션의 차이점은?

: 일단, 클라이언트와 서버 통신 시 정보를 유지하기 위해 사용하는 것이 '쿠키와 세션'

-> 세션은 브라우저를 닫거나, 서버에서 세션 삭제헀을 때 삭제되므로 쿠키보다 보안이 좋다!

-> 쿠키는 빠름, 세션은 '세션ID'를 통해 서버에서 다시 데이터를 참조해야 하므로 쿠키보다 비교적 느림

-> 쿠키의 저장 위치 : 클라이언트(로컬) / 세션의 저장 위치 : 서버

-> 쿠키 라이프 사이클 : 쿠키 저장시 설정(브라우저가 종료되도 만료시점이 지나지 않으면 자동삭제 되지 않음!) / 세션의 라이프 사이클 : 브라우저 종료시 삭제 (기간 별도 지정 가능!)
